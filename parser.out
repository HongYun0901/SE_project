Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COM
    DO
    GOTO
    LCOM
    RCOM
    SPACE

Grammar

Rule 0     S' -> stmts
Rule 1     stmts -> stmt
Rule 2     stmts -> stmt stmts
Rule 3     stmt -> <empty>
Rule 4     stmt -> expr
Rule 5     stmt -> ifstmt
Rule 6     stmt -> whilestmt
Rule 7     stmt -> forstmt
Rule 8     stmt -> switch_stmt
Rule 9     switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
Rule 10    case_stmt -> CASE bool_expr COLON stmts
Rule 11    case_stmt -> DEFAULT COLON stmts
Rule 12    case_stmt -> CASE bool_expr COLON stmts case_stmt
Rule 13    ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
Rule 14    ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt
Rule 15    elifs -> else
Rule 16    elifs -> elif
Rule 17    elifs -> elif elifs
Rule 18    elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE
Rule 19    else -> ELSE LBRACE stmts RBRACE
Rule 20    whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
Rule 21    forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt
Rule 22    for_expr -> contents SEMI contents SEMI contents
Rule 23    bool_expr -> contents
Rule 24    expr -> contents SEMI
Rule 25    expr -> func_expr SEMI
Rule 26    func_expr -> contents LP params RP
Rule 27    param -> contents
Rule 28    param -> func_expr
Rule 29    params -> param
Rule 30    params -> param params
Rule 31    contents -> CONTENT
Rule 32    contents -> CONTENT contents

Terminals, with rules where they appear

CASE                 : 10 12
COLON                : 10 11 12
COM                  : 
CONTENT              : 31 32
DEFAULT              : 11
DO                   : 
ELSE                 : 18 19
FOR                  : 21
GOTO                 : 
IF                   : 13 14 18
LBRACE               : 9 13 14 18 19 20 21
LCOM                 : 
LP                   : 9 13 14 18 20 21 26
RBRACE               : 9 13 14 18 19 20 21
RCOM                 : 
RP                   : 9 13 14 18 20 21 26
SEMI                 : 22 22 24 25
SPACE                : 
SWITCH               : 9
WHILE                : 20
error                : 

Nonterminals, with rules where they appear

bool_expr            : 9 10 12 13 14 18 20
case_stmt            : 9 12
contents             : 22 22 22 23 24 26 27 32
elif                 : 16 17
elifs                : 13 17
else                 : 15
expr                 : 4
for_expr             : 21
forstmt              : 7
func_expr            : 25 28
ifstmt               : 5
param                : 29 30
params               : 26 30
stmt                 : 1 2 9 13 14 20 21
stmts                : 2 10 11 12 13 14 18 19 20 21 0
switch_stmt          : 8
whilestmt            : 6

Parsing method: LALR

state 0

    (0) S' -> . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 1
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 1

    (0) S' -> stmts .



state 2

    (1) stmts -> stmt .
    (2) stmts -> stmt . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! reduce/reduce conflict for $end resolved using rule 1 (stmts -> stmt .)
  ! reduce/reduce conflict for RBRACE resolved using rule 1 (stmts -> stmt .)
  ! reduce/reduce conflict for CASE resolved using rule 1 (stmts -> stmt .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 1 (stmts -> stmt .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 1 (stmts -> stmt .)
    RBRACE          reduce using rule 1 (stmts -> stmt .)
    CASE            reduce using rule 1 (stmts -> stmt .)
    DEFAULT         reduce using rule 1 (stmts -> stmt .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]
  ! $end            [ reduce using rule 3 (stmt -> .) ]
  ! RBRACE          [ reduce using rule 3 (stmt -> .) ]
  ! CASE            [ reduce using rule 3 (stmt -> .) ]
  ! DEFAULT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 2
    stmts                          shift and go to state 15
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 3

    (4) stmt -> expr .

    IF              reduce using rule 4 (stmt -> expr .)
    WHILE           reduce using rule 4 (stmt -> expr .)
    FOR             reduce using rule 4 (stmt -> expr .)
    SWITCH          reduce using rule 4 (stmt -> expr .)
    CONTENT         reduce using rule 4 (stmt -> expr .)
    $end            reduce using rule 4 (stmt -> expr .)
    RBRACE          reduce using rule 4 (stmt -> expr .)
    CASE            reduce using rule 4 (stmt -> expr .)
    DEFAULT         reduce using rule 4 (stmt -> expr .)


state 4

    (5) stmt -> ifstmt .

    IF              reduce using rule 5 (stmt -> ifstmt .)
    WHILE           reduce using rule 5 (stmt -> ifstmt .)
    FOR             reduce using rule 5 (stmt -> ifstmt .)
    SWITCH          reduce using rule 5 (stmt -> ifstmt .)
    CONTENT         reduce using rule 5 (stmt -> ifstmt .)
    $end            reduce using rule 5 (stmt -> ifstmt .)
    RBRACE          reduce using rule 5 (stmt -> ifstmt .)
    CASE            reduce using rule 5 (stmt -> ifstmt .)
    DEFAULT         reduce using rule 5 (stmt -> ifstmt .)


state 5

    (6) stmt -> whilestmt .

    IF              reduce using rule 6 (stmt -> whilestmt .)
    WHILE           reduce using rule 6 (stmt -> whilestmt .)
    FOR             reduce using rule 6 (stmt -> whilestmt .)
    SWITCH          reduce using rule 6 (stmt -> whilestmt .)
    CONTENT         reduce using rule 6 (stmt -> whilestmt .)
    $end            reduce using rule 6 (stmt -> whilestmt .)
    RBRACE          reduce using rule 6 (stmt -> whilestmt .)
    CASE            reduce using rule 6 (stmt -> whilestmt .)
    DEFAULT         reduce using rule 6 (stmt -> whilestmt .)


state 6

    (7) stmt -> forstmt .

    IF              reduce using rule 7 (stmt -> forstmt .)
    WHILE           reduce using rule 7 (stmt -> forstmt .)
    FOR             reduce using rule 7 (stmt -> forstmt .)
    SWITCH          reduce using rule 7 (stmt -> forstmt .)
    CONTENT         reduce using rule 7 (stmt -> forstmt .)
    $end            reduce using rule 7 (stmt -> forstmt .)
    RBRACE          reduce using rule 7 (stmt -> forstmt .)
    CASE            reduce using rule 7 (stmt -> forstmt .)
    DEFAULT         reduce using rule 7 (stmt -> forstmt .)


state 7

    (8) stmt -> switch_stmt .

    IF              reduce using rule 8 (stmt -> switch_stmt .)
    WHILE           reduce using rule 8 (stmt -> switch_stmt .)
    FOR             reduce using rule 8 (stmt -> switch_stmt .)
    SWITCH          reduce using rule 8 (stmt -> switch_stmt .)
    CONTENT         reduce using rule 8 (stmt -> switch_stmt .)
    $end            reduce using rule 8 (stmt -> switch_stmt .)
    RBRACE          reduce using rule 8 (stmt -> switch_stmt .)
    CASE            reduce using rule 8 (stmt -> switch_stmt .)
    DEFAULT         reduce using rule 8 (stmt -> switch_stmt .)


state 8

    (24) expr -> contents . SEMI
    (26) func_expr -> contents . LP params RP

    SEMI            shift and go to state 16
    LP              shift and go to state 17


state 9

    (25) expr -> func_expr . SEMI

    SEMI            shift and go to state 18


state 10

    (13) ifstmt -> IF . LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> IF . LP bool_expr RP LBRACE stmts RBRACE stmt

    LP              shift and go to state 19


state 11

    (20) whilestmt -> WHILE . LP bool_expr RP LBRACE stmts RBRACE stmt

    LP              shift and go to state 20


state 12

    (21) forstmt -> FOR . LP for_expr RP LBRACE stmts RBRACE stmt

    LP              shift and go to state 21


state 13

    (9) switch_stmt -> SWITCH . LP bool_expr RP LBRACE case_stmt RBRACE stmt

    LP              shift and go to state 22


state 14

    (31) contents -> CONTENT .
    (32) contents -> CONTENT . contents
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents

  ! shift/reduce conflict for CONTENT resolved as shift
    SEMI            reduce using rule 31 (contents -> CONTENT .)
    LP              reduce using rule 31 (contents -> CONTENT .)
    RP              reduce using rule 31 (contents -> CONTENT .)
    COLON           reduce using rule 31 (contents -> CONTENT .)
    CONTENT         shift and go to state 14

  ! CONTENT         [ reduce using rule 31 (contents -> CONTENT .) ]

    contents                       shift and go to state 23

state 15

    (2) stmts -> stmt stmts .

    $end            reduce using rule 2 (stmts -> stmt stmts .)
    RBRACE          reduce using rule 2 (stmts -> stmt stmts .)
    CASE            reduce using rule 2 (stmts -> stmt stmts .)
    DEFAULT         reduce using rule 2 (stmts -> stmt stmts .)


state 16

    (24) expr -> contents SEMI .

    IF              reduce using rule 24 (expr -> contents SEMI .)
    WHILE           reduce using rule 24 (expr -> contents SEMI .)
    FOR             reduce using rule 24 (expr -> contents SEMI .)
    SWITCH          reduce using rule 24 (expr -> contents SEMI .)
    CONTENT         reduce using rule 24 (expr -> contents SEMI .)
    $end            reduce using rule 24 (expr -> contents SEMI .)
    RBRACE          reduce using rule 24 (expr -> contents SEMI .)
    CASE            reduce using rule 24 (expr -> contents SEMI .)
    DEFAULT         reduce using rule 24 (expr -> contents SEMI .)


state 17

    (26) func_expr -> contents LP . params RP
    (29) params -> . param
    (30) params -> . param params
    (27) param -> . contents
    (28) param -> . func_expr
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

    CONTENT         shift and go to state 14

    contents                       shift and go to state 24
    params                         shift and go to state 25
    param                          shift and go to state 26
    func_expr                      shift and go to state 27

state 18

    (25) expr -> func_expr SEMI .

    IF              reduce using rule 25 (expr -> func_expr SEMI .)
    WHILE           reduce using rule 25 (expr -> func_expr SEMI .)
    FOR             reduce using rule 25 (expr -> func_expr SEMI .)
    SWITCH          reduce using rule 25 (expr -> func_expr SEMI .)
    CONTENT         reduce using rule 25 (expr -> func_expr SEMI .)
    $end            reduce using rule 25 (expr -> func_expr SEMI .)
    RBRACE          reduce using rule 25 (expr -> func_expr SEMI .)
    CASE            reduce using rule 25 (expr -> func_expr SEMI .)
    DEFAULT         reduce using rule 25 (expr -> func_expr SEMI .)


state 19

    (13) ifstmt -> IF LP . bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> IF LP . bool_expr RP LBRACE stmts RBRACE stmt
    (23) bool_expr -> . contents
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 28
    contents                       shift and go to state 29

state 20

    (20) whilestmt -> WHILE LP . bool_expr RP LBRACE stmts RBRACE stmt
    (23) bool_expr -> . contents
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 30
    contents                       shift and go to state 29

state 21

    (21) forstmt -> FOR LP . for_expr RP LBRACE stmts RBRACE stmt
    (22) for_expr -> . contents SEMI contents SEMI contents
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    for_expr                       shift and go to state 31
    contents                       shift and go to state 32

state 22

    (9) switch_stmt -> SWITCH LP . bool_expr RP LBRACE case_stmt RBRACE stmt
    (23) bool_expr -> . contents
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 33
    contents                       shift and go to state 29

state 23

    (32) contents -> CONTENT contents .

    SEMI            reduce using rule 32 (contents -> CONTENT contents .)
    LP              reduce using rule 32 (contents -> CONTENT contents .)
    CONTENT         reduce using rule 32 (contents -> CONTENT contents .)
    RP              reduce using rule 32 (contents -> CONTENT contents .)
    COLON           reduce using rule 32 (contents -> CONTENT contents .)


state 24

    (27) param -> contents .
    (26) func_expr -> contents . LP params RP

    CONTENT         reduce using rule 27 (param -> contents .)
    RP              reduce using rule 27 (param -> contents .)
    LP              shift and go to state 17


state 25

    (26) func_expr -> contents LP params . RP

    RP              shift and go to state 34


state 26

    (29) params -> param .
    (30) params -> param . params
    (29) params -> . param
    (30) params -> . param params
    (27) param -> . contents
    (28) param -> . func_expr
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

    RP              reduce using rule 29 (params -> param .)
    CONTENT         shift and go to state 14

    param                          shift and go to state 26
    params                         shift and go to state 35
    contents                       shift and go to state 24
    func_expr                      shift and go to state 27

state 27

    (28) param -> func_expr .

    CONTENT         reduce using rule 28 (param -> func_expr .)
    RP              reduce using rule 28 (param -> func_expr .)


state 28

    (13) ifstmt -> IF LP bool_expr . RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> IF LP bool_expr . RP LBRACE stmts RBRACE stmt

    RP              shift and go to state 36


state 29

    (23) bool_expr -> contents .

    RP              reduce using rule 23 (bool_expr -> contents .)
    COLON           reduce using rule 23 (bool_expr -> contents .)


state 30

    (20) whilestmt -> WHILE LP bool_expr . RP LBRACE stmts RBRACE stmt

    RP              shift and go to state 37


state 31

    (21) forstmt -> FOR LP for_expr . RP LBRACE stmts RBRACE stmt

    RP              shift and go to state 38


state 32

    (22) for_expr -> contents . SEMI contents SEMI contents

    SEMI            shift and go to state 39


state 33

    (9) switch_stmt -> SWITCH LP bool_expr . RP LBRACE case_stmt RBRACE stmt

    RP              shift and go to state 40


state 34

    (26) func_expr -> contents LP params RP .

    SEMI            reduce using rule 26 (func_expr -> contents LP params RP .)
    CONTENT         reduce using rule 26 (func_expr -> contents LP params RP .)
    RP              reduce using rule 26 (func_expr -> contents LP params RP .)


state 35

    (30) params -> param params .

    RP              reduce using rule 30 (params -> param params .)


state 36

    (13) ifstmt -> IF LP bool_expr RP . LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> IF LP bool_expr RP . LBRACE stmts RBRACE stmt

    LBRACE          shift and go to state 41


state 37

    (20) whilestmt -> WHILE LP bool_expr RP . LBRACE stmts RBRACE stmt

    LBRACE          shift and go to state 42


state 38

    (21) forstmt -> FOR LP for_expr RP . LBRACE stmts RBRACE stmt

    LBRACE          shift and go to state 43


state 39

    (22) for_expr -> contents SEMI . contents SEMI contents
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    contents                       shift and go to state 44

state 40

    (9) switch_stmt -> SWITCH LP bool_expr RP . LBRACE case_stmt RBRACE stmt

    LBRACE          shift and go to state 45


state 41

    (13) ifstmt -> IF LP bool_expr RP LBRACE . stmts RBRACE elifs stmt
    (14) ifstmt -> IF LP bool_expr RP LBRACE . stmts RBRACE stmt
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 46
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 42

    (20) whilestmt -> WHILE LP bool_expr RP LBRACE . stmts RBRACE stmt
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 47
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 43

    (21) forstmt -> FOR LP for_expr RP LBRACE . stmts RBRACE stmt
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 48
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 44

    (22) for_expr -> contents SEMI contents . SEMI contents

    SEMI            shift and go to state 49


state 45

    (9) switch_stmt -> SWITCH LP bool_expr RP LBRACE . case_stmt RBRACE stmt
    (10) case_stmt -> . CASE bool_expr COLON stmts
    (11) case_stmt -> . DEFAULT COLON stmts
    (12) case_stmt -> . CASE bool_expr COLON stmts case_stmt

    CASE            shift and go to state 51
    DEFAULT         shift and go to state 52

    case_stmt                      shift and go to state 50

state 46

    (13) ifstmt -> IF LP bool_expr RP LBRACE stmts . RBRACE elifs stmt
    (14) ifstmt -> IF LP bool_expr RP LBRACE stmts . RBRACE stmt

    RBRACE          shift and go to state 53


state 47

    (20) whilestmt -> WHILE LP bool_expr RP LBRACE stmts . RBRACE stmt

    RBRACE          shift and go to state 54


state 48

    (21) forstmt -> FOR LP for_expr RP LBRACE stmts . RBRACE stmt

    RBRACE          shift and go to state 55


state 49

    (22) for_expr -> contents SEMI contents SEMI . contents
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    contents                       shift and go to state 56

state 50

    (9) switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt . RBRACE stmt

    RBRACE          shift and go to state 57


state 51

    (10) case_stmt -> CASE . bool_expr COLON stmts
    (12) case_stmt -> CASE . bool_expr COLON stmts case_stmt
    (23) bool_expr -> . contents
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 58
    contents                       shift and go to state 29

state 52

    (11) case_stmt -> DEFAULT . COLON stmts

    COLON           shift and go to state 59


state 53

    (13) ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE . elifs stmt
    (14) ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE . stmt
    (15) elifs -> . else
    (16) elifs -> . elif
    (17) elifs -> . elif elifs
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (19) else -> . ELSE LBRACE stmts RBRACE
    (18) elif -> . ELSE IF LP bool_expr RP LBRACE stmts RBRACE
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    ELSE            shift and go to state 64
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    elifs                          shift and go to state 60
    stmt                           shift and go to state 61
    else                           shift and go to state 62
    elif                           shift and go to state 63
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 54

    (20) whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 65
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 55

    (21) forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 66
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 56

    (22) for_expr -> contents SEMI contents SEMI contents .

    RP              reduce using rule 22 (for_expr -> contents SEMI contents SEMI contents .)


state 57

    (9) switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 67
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 58

    (10) case_stmt -> CASE bool_expr . COLON stmts
    (12) case_stmt -> CASE bool_expr . COLON stmts case_stmt

    COLON           shift and go to state 68


state 59

    (11) case_stmt -> DEFAULT COLON . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 69
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 60

    (13) ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 70
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 61

    (14) ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .

    IF              reduce using rule 14 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .)
    WHILE           reduce using rule 14 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .)
    FOR             reduce using rule 14 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .)
    SWITCH          reduce using rule 14 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .)
    CONTENT         reduce using rule 14 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .)
    $end            reduce using rule 14 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .)
    RBRACE          reduce using rule 14 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .)
    CASE            reduce using rule 14 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .)
    DEFAULT         reduce using rule 14 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE stmt .)


state 62

    (15) elifs -> else .

    IF              reduce using rule 15 (elifs -> else .)
    WHILE           reduce using rule 15 (elifs -> else .)
    FOR             reduce using rule 15 (elifs -> else .)
    SWITCH          reduce using rule 15 (elifs -> else .)
    CONTENT         reduce using rule 15 (elifs -> else .)
    $end            reduce using rule 15 (elifs -> else .)
    RBRACE          reduce using rule 15 (elifs -> else .)
    CASE            reduce using rule 15 (elifs -> else .)
    DEFAULT         reduce using rule 15 (elifs -> else .)


state 63

    (16) elifs -> elif .
    (17) elifs -> elif . elifs
    (15) elifs -> . else
    (16) elifs -> . elif
    (17) elifs -> . elif elifs
    (19) else -> . ELSE LBRACE stmts RBRACE
    (18) elif -> . ELSE IF LP bool_expr RP LBRACE stmts RBRACE

    IF              reduce using rule 16 (elifs -> elif .)
    WHILE           reduce using rule 16 (elifs -> elif .)
    FOR             reduce using rule 16 (elifs -> elif .)
    SWITCH          reduce using rule 16 (elifs -> elif .)
    CONTENT         reduce using rule 16 (elifs -> elif .)
    $end            reduce using rule 16 (elifs -> elif .)
    RBRACE          reduce using rule 16 (elifs -> elif .)
    CASE            reduce using rule 16 (elifs -> elif .)
    DEFAULT         reduce using rule 16 (elifs -> elif .)
    ELSE            shift and go to state 64

    elif                           shift and go to state 63
    elifs                          shift and go to state 71
    else                           shift and go to state 62

state 64

    (19) else -> ELSE . LBRACE stmts RBRACE
    (18) elif -> ELSE . IF LP bool_expr RP LBRACE stmts RBRACE

    LBRACE          shift and go to state 72
    IF              shift and go to state 73


state 65

    (20) whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .

    IF              reduce using rule 20 (whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .)
    WHILE           reduce using rule 20 (whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .)
    FOR             reduce using rule 20 (whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .)
    SWITCH          reduce using rule 20 (whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .)
    CONTENT         reduce using rule 20 (whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .)
    $end            reduce using rule 20 (whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .)
    RBRACE          reduce using rule 20 (whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .)
    CASE            reduce using rule 20 (whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .)
    DEFAULT         reduce using rule 20 (whilestmt -> WHILE LP bool_expr RP LBRACE stmts RBRACE stmt .)


state 66

    (21) forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .

    IF              reduce using rule 21 (forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .)
    WHILE           reduce using rule 21 (forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .)
    FOR             reduce using rule 21 (forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .)
    SWITCH          reduce using rule 21 (forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .)
    CONTENT         reduce using rule 21 (forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .)
    $end            reduce using rule 21 (forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .)
    RBRACE          reduce using rule 21 (forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .)
    CASE            reduce using rule 21 (forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .)
    DEFAULT         reduce using rule 21 (forstmt -> FOR LP for_expr RP LBRACE stmts RBRACE stmt .)


state 67

    (9) switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .

    IF              reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    WHILE           reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    FOR             reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    SWITCH          reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    CONTENT         reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    $end            reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    RBRACE          reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    CASE            reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    DEFAULT         reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)


state 68

    (10) case_stmt -> CASE bool_expr COLON . stmts
    (12) case_stmt -> CASE bool_expr COLON . stmts case_stmt
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 74
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 69

    (11) case_stmt -> DEFAULT COLON stmts .

    RBRACE          reduce using rule 11 (case_stmt -> DEFAULT COLON stmts .)


state 70

    (13) ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .

    IF              reduce using rule 13 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .)
    WHILE           reduce using rule 13 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .)
    FOR             reduce using rule 13 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .)
    SWITCH          reduce using rule 13 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .)
    CONTENT         reduce using rule 13 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .)
    $end            reduce using rule 13 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .)
    RBRACE          reduce using rule 13 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .)
    CASE            reduce using rule 13 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .)
    DEFAULT         reduce using rule 13 (ifstmt -> IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt .)


state 71

    (17) elifs -> elif elifs .

    IF              reduce using rule 17 (elifs -> elif elifs .)
    WHILE           reduce using rule 17 (elifs -> elif elifs .)
    FOR             reduce using rule 17 (elifs -> elif elifs .)
    SWITCH          reduce using rule 17 (elifs -> elif elifs .)
    CONTENT         reduce using rule 17 (elifs -> elif elifs .)
    $end            reduce using rule 17 (elifs -> elif elifs .)
    RBRACE          reduce using rule 17 (elifs -> elif elifs .)
    CASE            reduce using rule 17 (elifs -> elif elifs .)
    DEFAULT         reduce using rule 17 (elifs -> elif elifs .)


state 72

    (19) else -> ELSE LBRACE . stmts RBRACE
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 75
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 73

    (18) elif -> ELSE IF . LP bool_expr RP LBRACE stmts RBRACE

    LP              shift and go to state 76


state 74

    (10) case_stmt -> CASE bool_expr COLON stmts .
    (12) case_stmt -> CASE bool_expr COLON stmts . case_stmt
    (10) case_stmt -> . CASE bool_expr COLON stmts
    (11) case_stmt -> . DEFAULT COLON stmts
    (12) case_stmt -> . CASE bool_expr COLON stmts case_stmt

    RBRACE          reduce using rule 10 (case_stmt -> CASE bool_expr COLON stmts .)
    CASE            shift and go to state 51
    DEFAULT         shift and go to state 52

    case_stmt                      shift and go to state 77

state 75

    (19) else -> ELSE LBRACE stmts . RBRACE

    RBRACE          shift and go to state 78


state 76

    (18) elif -> ELSE IF LP . bool_expr RP LBRACE stmts RBRACE
    (23) bool_expr -> . contents
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 79
    contents                       shift and go to state 29

state 77

    (12) case_stmt -> CASE bool_expr COLON stmts case_stmt .

    RBRACE          reduce using rule 12 (case_stmt -> CASE bool_expr COLON stmts case_stmt .)


state 78

    (19) else -> ELSE LBRACE stmts RBRACE .

    IF              reduce using rule 19 (else -> ELSE LBRACE stmts RBRACE .)
    WHILE           reduce using rule 19 (else -> ELSE LBRACE stmts RBRACE .)
    FOR             reduce using rule 19 (else -> ELSE LBRACE stmts RBRACE .)
    SWITCH          reduce using rule 19 (else -> ELSE LBRACE stmts RBRACE .)
    CONTENT         reduce using rule 19 (else -> ELSE LBRACE stmts RBRACE .)
    $end            reduce using rule 19 (else -> ELSE LBRACE stmts RBRACE .)
    RBRACE          reduce using rule 19 (else -> ELSE LBRACE stmts RBRACE .)
    CASE            reduce using rule 19 (else -> ELSE LBRACE stmts RBRACE .)
    DEFAULT         reduce using rule 19 (else -> ELSE LBRACE stmts RBRACE .)


state 79

    (18) elif -> ELSE IF LP bool_expr . RP LBRACE stmts RBRACE

    RP              shift and go to state 80


state 80

    (18) elif -> ELSE IF LP bool_expr RP . LBRACE stmts RBRACE

    LBRACE          shift and go to state 81


state 81

    (18) elif -> ELSE IF LP bool_expr RP LBRACE . stmts RBRACE
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (24) expr -> . contents SEMI
    (25) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP LBRACE stmts RBRACE stmt
    (20) whilestmt -> . WHILE LP bool_expr RP LBRACE stmts RBRACE stmt
    (21) forstmt -> . FOR LP for_expr RP LBRACE stmts RBRACE stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (31) contents -> . CONTENT
    (32) contents -> . CONTENT contents
    (26) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 82
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 82

    (18) elif -> ELSE IF LP bool_expr RP LBRACE stmts . RBRACE

    RBRACE          shift and go to state 83


state 83

    (18) elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .

    ELSE            reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)
    IF              reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)
    WHILE           reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)
    FOR             reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)
    SWITCH          reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)
    CONTENT         reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)
    $end            reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)
    RBRACE          reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)
    CASE            reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)
    DEFAULT         reduce using rule 18 (elif -> ELSE IF LP bool_expr RP LBRACE stmts RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 2 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 2 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 14 resolved as shift
WARNING: shift/reduce conflict for IF in state 41 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 41 resolved as shift
WARNING: shift/reduce conflict for FOR in state 41 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 41 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 42 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 42 resolved as shift
WARNING: shift/reduce conflict for FOR in state 42 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 42 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 42 resolved as shift
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 43 resolved as shift
WARNING: shift/reduce conflict for FOR in state 43 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 43 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 43 resolved as shift
WARNING: shift/reduce conflict for IF in state 53 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 53 resolved as shift
WARNING: shift/reduce conflict for FOR in state 53 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 53 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 53 resolved as shift
WARNING: shift/reduce conflict for IF in state 54 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 54 resolved as shift
WARNING: shift/reduce conflict for FOR in state 54 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 54 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 54 resolved as shift
WARNING: shift/reduce conflict for IF in state 55 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 55 resolved as shift
WARNING: shift/reduce conflict for FOR in state 55 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 55 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 55 resolved as shift
WARNING: shift/reduce conflict for IF in state 57 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 57 resolved as shift
WARNING: shift/reduce conflict for FOR in state 57 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 57 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 57 resolved as shift
WARNING: shift/reduce conflict for IF in state 59 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 59 resolved as shift
WARNING: shift/reduce conflict for FOR in state 59 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 59 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 59 resolved as shift
WARNING: shift/reduce conflict for IF in state 60 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 60 resolved as shift
WARNING: shift/reduce conflict for FOR in state 60 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 60 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 60 resolved as shift
WARNING: shift/reduce conflict for IF in state 68 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 68 resolved as shift
WARNING: shift/reduce conflict for FOR in state 68 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 68 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 68 resolved as shift
WARNING: shift/reduce conflict for IF in state 72 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 72 resolved as shift
WARNING: shift/reduce conflict for FOR in state 72 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 72 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 72 resolved as shift
WARNING: shift/reduce conflict for IF in state 81 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 81 resolved as shift
WARNING: shift/reduce conflict for FOR in state 81 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 81 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 81 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (stmts -> stmt)
WARNING: rejected rule (stmt -> <empty>) in state 2
