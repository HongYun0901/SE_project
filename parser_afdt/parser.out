Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COM
    DO
    GOTO
    LCOM
    RCOM
    SPACE

Grammar

Rule 0     S' -> stmts
Rule 1     stmts -> stmt
Rule 2     stmts -> stmt stmts
Rule 3     stmt -> <empty>
Rule 4     stmt -> expr
Rule 5     stmt -> ifstmt
Rule 6     stmt -> whilestmt
Rule 7     stmt -> forstmt
Rule 8     stmt -> switch_stmt
Rule 9     switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
Rule 10    case_stmt -> CASE bool_expr COLON stmts
Rule 11    case_stmt -> DEFAULT COLON stmts
Rule 12    case_stmt -> CASE bool_expr COLON stmts case_stmt
Rule 13    ifstmt -> IF LP bool_expr RP stmt_block elifs stmt
Rule 14    ifstmt -> IF LP bool_expr RP stmt_block stmt
Rule 15    stmt_block -> LBRACE stmts RBRACE
Rule 16    stmt_block -> stmt
Rule 17    elifs -> else
Rule 18    elifs -> elif
Rule 19    elifs -> elif elifs
Rule 20    elif -> ELSE IF LP bool_expr RP stmt_block
Rule 21    else -> ELSE stmt_block
Rule 22    whilestmt -> WHILE LP bool_expr RP stmt_block stmt
Rule 23    forstmt -> FOR LP for_expr RP stmt_block stmt
Rule 24    for_expr -> contents SEMI contents SEMI contents
Rule 25    bool_expr -> contents
Rule 26    expr -> contents SEMI
Rule 27    expr -> func_expr SEMI
Rule 28    func_expr -> contents LP params RP
Rule 29    param -> contents
Rule 30    param -> func_expr
Rule 31    params -> <empty>
Rule 32    params -> param
Rule 33    params -> param params
Rule 34    contents -> CONTENT
Rule 35    contents -> CONTENT contents

Terminals, with rules where they appear

CASE                 : 10 12
COLON                : 10 11 12
COM                  : 
CONTENT              : 34 35
DEFAULT              : 11
DO                   : 
ELSE                 : 20 21
FOR                  : 23
GOTO                 : 
IF                   : 13 14 20
LBRACE               : 9 15
LCOM                 : 
LP                   : 9 13 14 20 22 23 28
RBRACE               : 9 15
RCOM                 : 
RP                   : 9 13 14 20 22 23 28
SEMI                 : 24 24 26 27
SPACE                : 
SWITCH               : 9
WHILE                : 22
error                : 

Nonterminals, with rules where they appear

bool_expr            : 9 10 12 13 14 20 22
case_stmt            : 9 12
contents             : 24 24 24 25 26 28 29 35
elif                 : 18 19
elifs                : 13 19
else                 : 17
expr                 : 4
for_expr             : 23
forstmt              : 7
func_expr            : 27 30
ifstmt               : 5
param                : 32 33
params               : 28 33
stmt                 : 1 2 9 13 14 16 22 23
stmt_block           : 13 14 20 21 22 23
stmts                : 2 10 11 12 15 0
switch_stmt          : 8
whilestmt            : 6

Parsing method: LALR

state 0

    (0) S' -> . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 1
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 1

    (0) S' -> stmts .



state 2

    (1) stmts -> stmt .
    (2) stmts -> stmt . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! reduce/reduce conflict for $end resolved using rule 1 (stmts -> stmt .)
  ! reduce/reduce conflict for RBRACE resolved using rule 1 (stmts -> stmt .)
  ! reduce/reduce conflict for CASE resolved using rule 1 (stmts -> stmt .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 1 (stmts -> stmt .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 1 (stmts -> stmt .)
    RBRACE          reduce using rule 1 (stmts -> stmt .)
    CASE            reduce using rule 1 (stmts -> stmt .)
    DEFAULT         reduce using rule 1 (stmts -> stmt .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]
  ! $end            [ reduce using rule 3 (stmt -> .) ]
  ! RBRACE          [ reduce using rule 3 (stmt -> .) ]
  ! CASE            [ reduce using rule 3 (stmt -> .) ]
  ! DEFAULT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 2
    stmts                          shift and go to state 15
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 3

    (4) stmt -> expr .

    IF              reduce using rule 4 (stmt -> expr .)
    WHILE           reduce using rule 4 (stmt -> expr .)
    FOR             reduce using rule 4 (stmt -> expr .)
    SWITCH          reduce using rule 4 (stmt -> expr .)
    CONTENT         reduce using rule 4 (stmt -> expr .)
    $end            reduce using rule 4 (stmt -> expr .)
    RBRACE          reduce using rule 4 (stmt -> expr .)
    CASE            reduce using rule 4 (stmt -> expr .)
    DEFAULT         reduce using rule 4 (stmt -> expr .)
    ELSE            reduce using rule 4 (stmt -> expr .)


state 4

    (5) stmt -> ifstmt .

    IF              reduce using rule 5 (stmt -> ifstmt .)
    WHILE           reduce using rule 5 (stmt -> ifstmt .)
    FOR             reduce using rule 5 (stmt -> ifstmt .)
    SWITCH          reduce using rule 5 (stmt -> ifstmt .)
    CONTENT         reduce using rule 5 (stmt -> ifstmt .)
    $end            reduce using rule 5 (stmt -> ifstmt .)
    RBRACE          reduce using rule 5 (stmt -> ifstmt .)
    CASE            reduce using rule 5 (stmt -> ifstmt .)
    DEFAULT         reduce using rule 5 (stmt -> ifstmt .)
    ELSE            reduce using rule 5 (stmt -> ifstmt .)


state 5

    (6) stmt -> whilestmt .

    IF              reduce using rule 6 (stmt -> whilestmt .)
    WHILE           reduce using rule 6 (stmt -> whilestmt .)
    FOR             reduce using rule 6 (stmt -> whilestmt .)
    SWITCH          reduce using rule 6 (stmt -> whilestmt .)
    CONTENT         reduce using rule 6 (stmt -> whilestmt .)
    $end            reduce using rule 6 (stmt -> whilestmt .)
    RBRACE          reduce using rule 6 (stmt -> whilestmt .)
    CASE            reduce using rule 6 (stmt -> whilestmt .)
    DEFAULT         reduce using rule 6 (stmt -> whilestmt .)
    ELSE            reduce using rule 6 (stmt -> whilestmt .)


state 6

    (7) stmt -> forstmt .

    IF              reduce using rule 7 (stmt -> forstmt .)
    WHILE           reduce using rule 7 (stmt -> forstmt .)
    FOR             reduce using rule 7 (stmt -> forstmt .)
    SWITCH          reduce using rule 7 (stmt -> forstmt .)
    CONTENT         reduce using rule 7 (stmt -> forstmt .)
    $end            reduce using rule 7 (stmt -> forstmt .)
    RBRACE          reduce using rule 7 (stmt -> forstmt .)
    CASE            reduce using rule 7 (stmt -> forstmt .)
    DEFAULT         reduce using rule 7 (stmt -> forstmt .)
    ELSE            reduce using rule 7 (stmt -> forstmt .)


state 7

    (8) stmt -> switch_stmt .

    IF              reduce using rule 8 (stmt -> switch_stmt .)
    WHILE           reduce using rule 8 (stmt -> switch_stmt .)
    FOR             reduce using rule 8 (stmt -> switch_stmt .)
    SWITCH          reduce using rule 8 (stmt -> switch_stmt .)
    CONTENT         reduce using rule 8 (stmt -> switch_stmt .)
    $end            reduce using rule 8 (stmt -> switch_stmt .)
    RBRACE          reduce using rule 8 (stmt -> switch_stmt .)
    CASE            reduce using rule 8 (stmt -> switch_stmt .)
    DEFAULT         reduce using rule 8 (stmt -> switch_stmt .)
    ELSE            reduce using rule 8 (stmt -> switch_stmt .)


state 8

    (26) expr -> contents . SEMI
    (28) func_expr -> contents . LP params RP

    SEMI            shift and go to state 16
    LP              shift and go to state 17


state 9

    (27) expr -> func_expr . SEMI

    SEMI            shift and go to state 18


state 10

    (13) ifstmt -> IF . LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> IF . LP bool_expr RP stmt_block stmt

    LP              shift and go to state 19


state 11

    (22) whilestmt -> WHILE . LP bool_expr RP stmt_block stmt

    LP              shift and go to state 20


state 12

    (23) forstmt -> FOR . LP for_expr RP stmt_block stmt

    LP              shift and go to state 21


state 13

    (9) switch_stmt -> SWITCH . LP bool_expr RP LBRACE case_stmt RBRACE stmt

    LP              shift and go to state 22


state 14

    (34) contents -> CONTENT .
    (35) contents -> CONTENT . contents
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents

  ! shift/reduce conflict for CONTENT resolved as shift
    SEMI            reduce using rule 34 (contents -> CONTENT .)
    LP              reduce using rule 34 (contents -> CONTENT .)
    RP              reduce using rule 34 (contents -> CONTENT .)
    COLON           reduce using rule 34 (contents -> CONTENT .)
    CONTENT         shift and go to state 14

  ! CONTENT         [ reduce using rule 34 (contents -> CONTENT .) ]

    contents                       shift and go to state 23

state 15

    (2) stmts -> stmt stmts .

    $end            reduce using rule 2 (stmts -> stmt stmts .)
    RBRACE          reduce using rule 2 (stmts -> stmt stmts .)
    CASE            reduce using rule 2 (stmts -> stmt stmts .)
    DEFAULT         reduce using rule 2 (stmts -> stmt stmts .)


state 16

    (26) expr -> contents SEMI .

    IF              reduce using rule 26 (expr -> contents SEMI .)
    WHILE           reduce using rule 26 (expr -> contents SEMI .)
    FOR             reduce using rule 26 (expr -> contents SEMI .)
    SWITCH          reduce using rule 26 (expr -> contents SEMI .)
    CONTENT         reduce using rule 26 (expr -> contents SEMI .)
    $end            reduce using rule 26 (expr -> contents SEMI .)
    RBRACE          reduce using rule 26 (expr -> contents SEMI .)
    CASE            reduce using rule 26 (expr -> contents SEMI .)
    DEFAULT         reduce using rule 26 (expr -> contents SEMI .)
    ELSE            reduce using rule 26 (expr -> contents SEMI .)


state 17

    (28) func_expr -> contents LP . params RP
    (31) params -> .
    (32) params -> . param
    (33) params -> . param params
    (29) param -> . contents
    (30) param -> . func_expr
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

    RP              reduce using rule 31 (params -> .)
    CONTENT         shift and go to state 14

    contents                       shift and go to state 24
    params                         shift and go to state 25
    param                          shift and go to state 26
    func_expr                      shift and go to state 27

state 18

    (27) expr -> func_expr SEMI .

    IF              reduce using rule 27 (expr -> func_expr SEMI .)
    WHILE           reduce using rule 27 (expr -> func_expr SEMI .)
    FOR             reduce using rule 27 (expr -> func_expr SEMI .)
    SWITCH          reduce using rule 27 (expr -> func_expr SEMI .)
    CONTENT         reduce using rule 27 (expr -> func_expr SEMI .)
    $end            reduce using rule 27 (expr -> func_expr SEMI .)
    RBRACE          reduce using rule 27 (expr -> func_expr SEMI .)
    CASE            reduce using rule 27 (expr -> func_expr SEMI .)
    DEFAULT         reduce using rule 27 (expr -> func_expr SEMI .)
    ELSE            reduce using rule 27 (expr -> func_expr SEMI .)


state 19

    (13) ifstmt -> IF LP . bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> IF LP . bool_expr RP stmt_block stmt
    (25) bool_expr -> . contents
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 28
    contents                       shift and go to state 29

state 20

    (22) whilestmt -> WHILE LP . bool_expr RP stmt_block stmt
    (25) bool_expr -> . contents
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 30
    contents                       shift and go to state 29

state 21

    (23) forstmt -> FOR LP . for_expr RP stmt_block stmt
    (24) for_expr -> . contents SEMI contents SEMI contents
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    for_expr                       shift and go to state 31
    contents                       shift and go to state 32

state 22

    (9) switch_stmt -> SWITCH LP . bool_expr RP LBRACE case_stmt RBRACE stmt
    (25) bool_expr -> . contents
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 33
    contents                       shift and go to state 29

state 23

    (35) contents -> CONTENT contents .

    SEMI            reduce using rule 35 (contents -> CONTENT contents .)
    LP              reduce using rule 35 (contents -> CONTENT contents .)
    CONTENT         reduce using rule 35 (contents -> CONTENT contents .)
    RP              reduce using rule 35 (contents -> CONTENT contents .)
    COLON           reduce using rule 35 (contents -> CONTENT contents .)


state 24

    (29) param -> contents .
    (28) func_expr -> contents . LP params RP

    CONTENT         reduce using rule 29 (param -> contents .)
    RP              reduce using rule 29 (param -> contents .)
    LP              shift and go to state 17


state 25

    (28) func_expr -> contents LP params . RP

    RP              shift and go to state 34


state 26

    (32) params -> param .
    (33) params -> param . params
    (31) params -> .
    (32) params -> . param
    (33) params -> . param params
    (29) param -> . contents
    (30) param -> . func_expr
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! reduce/reduce conflict for RP resolved using rule 31 (params -> .)
    RP              reduce using rule 31 (params -> .)
    CONTENT         shift and go to state 14

  ! RP              [ reduce using rule 32 (params -> param .) ]

    param                          shift and go to state 26
    params                         shift and go to state 35
    contents                       shift and go to state 24
    func_expr                      shift and go to state 27

state 27

    (30) param -> func_expr .

    CONTENT         reduce using rule 30 (param -> func_expr .)
    RP              reduce using rule 30 (param -> func_expr .)


state 28

    (13) ifstmt -> IF LP bool_expr . RP stmt_block elifs stmt
    (14) ifstmt -> IF LP bool_expr . RP stmt_block stmt

    RP              shift and go to state 36


state 29

    (25) bool_expr -> contents .

    RP              reduce using rule 25 (bool_expr -> contents .)
    COLON           reduce using rule 25 (bool_expr -> contents .)


state 30

    (22) whilestmt -> WHILE LP bool_expr . RP stmt_block stmt

    RP              shift and go to state 37


state 31

    (23) forstmt -> FOR LP for_expr . RP stmt_block stmt

    RP              shift and go to state 38


state 32

    (24) for_expr -> contents . SEMI contents SEMI contents

    SEMI            shift and go to state 39


state 33

    (9) switch_stmt -> SWITCH LP bool_expr . RP LBRACE case_stmt RBRACE stmt

    RP              shift and go to state 40


state 34

    (28) func_expr -> contents LP params RP .

    SEMI            reduce using rule 28 (func_expr -> contents LP params RP .)
    CONTENT         reduce using rule 28 (func_expr -> contents LP params RP .)
    RP              reduce using rule 28 (func_expr -> contents LP params RP .)


state 35

    (33) params -> param params .

    RP              reduce using rule 33 (params -> param params .)


state 36

    (13) ifstmt -> IF LP bool_expr RP . stmt_block elifs stmt
    (14) ifstmt -> IF LP bool_expr RP . stmt_block stmt
    (15) stmt_block -> . LBRACE stmts RBRACE
    (16) stmt_block -> . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    LBRACE          shift and go to state 43
    ELSE            reduce using rule 3 (stmt -> .)
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt_block                     shift and go to state 41
    stmt                           shift and go to state 42
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 37

    (22) whilestmt -> WHILE LP bool_expr RP . stmt_block stmt
    (15) stmt_block -> . LBRACE stmts RBRACE
    (16) stmt_block -> . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    LBRACE          shift and go to state 43
    ELSE            reduce using rule 3 (stmt -> .)
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt_block                     shift and go to state 44
    stmt                           shift and go to state 42
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 38

    (23) forstmt -> FOR LP for_expr RP . stmt_block stmt
    (15) stmt_block -> . LBRACE stmts RBRACE
    (16) stmt_block -> . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    LBRACE          shift and go to state 43
    ELSE            reduce using rule 3 (stmt -> .)
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt_block                     shift and go to state 45
    stmt                           shift and go to state 42
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 39

    (24) for_expr -> contents SEMI . contents SEMI contents
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    contents                       shift and go to state 46

state 40

    (9) switch_stmt -> SWITCH LP bool_expr RP . LBRACE case_stmt RBRACE stmt

    LBRACE          shift and go to state 47


state 41

    (13) ifstmt -> IF LP bool_expr RP stmt_block . elifs stmt
    (14) ifstmt -> IF LP bool_expr RP stmt_block . stmt
    (17) elifs -> . else
    (18) elifs -> . elif
    (19) elifs -> . elif elifs
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (21) else -> . ELSE stmt_block
    (20) elif -> . ELSE IF LP bool_expr RP stmt_block
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    ELSE            shift and go to state 52
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! ELSE            [ reduce using rule 3 (stmt -> .) ]
  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    elifs                          shift and go to state 48
    stmt                           shift and go to state 49
    else                           shift and go to state 50
    elif                           shift and go to state 51
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 42

    (16) stmt_block -> stmt .

    ELSE            reduce using rule 16 (stmt_block -> stmt .)
    IF              reduce using rule 16 (stmt_block -> stmt .)
    WHILE           reduce using rule 16 (stmt_block -> stmt .)
    FOR             reduce using rule 16 (stmt_block -> stmt .)
    SWITCH          reduce using rule 16 (stmt_block -> stmt .)
    CONTENT         reduce using rule 16 (stmt_block -> stmt .)
    $end            reduce using rule 16 (stmt_block -> stmt .)
    RBRACE          reduce using rule 16 (stmt_block -> stmt .)
    CASE            reduce using rule 16 (stmt_block -> stmt .)
    DEFAULT         reduce using rule 16 (stmt_block -> stmt .)


state 43

    (15) stmt_block -> LBRACE . stmts RBRACE
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 53
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 44

    (22) whilestmt -> WHILE LP bool_expr RP stmt_block . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    ELSE            reduce using rule 3 (stmt -> .)
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 54
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 45

    (23) forstmt -> FOR LP for_expr RP stmt_block . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    ELSE            reduce using rule 3 (stmt -> .)
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 55
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 46

    (24) for_expr -> contents SEMI contents . SEMI contents

    SEMI            shift and go to state 56


state 47

    (9) switch_stmt -> SWITCH LP bool_expr RP LBRACE . case_stmt RBRACE stmt
    (10) case_stmt -> . CASE bool_expr COLON stmts
    (11) case_stmt -> . DEFAULT COLON stmts
    (12) case_stmt -> . CASE bool_expr COLON stmts case_stmt

    CASE            shift and go to state 58
    DEFAULT         shift and go to state 59

    case_stmt                      shift and go to state 57

state 48

    (13) ifstmt -> IF LP bool_expr RP stmt_block elifs . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    ELSE            reduce using rule 3 (stmt -> .)
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 60
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 49

    (14) ifstmt -> IF LP bool_expr RP stmt_block stmt .

    IF              reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)
    WHILE           reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)
    FOR             reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)
    SWITCH          reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)
    CONTENT         reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)
    $end            reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)
    RBRACE          reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)
    CASE            reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)
    DEFAULT         reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)
    ELSE            reduce using rule 14 (ifstmt -> IF LP bool_expr RP stmt_block stmt .)


state 50

    (17) elifs -> else .

    ELSE            reduce using rule 17 (elifs -> else .)
    IF              reduce using rule 17 (elifs -> else .)
    WHILE           reduce using rule 17 (elifs -> else .)
    FOR             reduce using rule 17 (elifs -> else .)
    SWITCH          reduce using rule 17 (elifs -> else .)
    CONTENT         reduce using rule 17 (elifs -> else .)
    $end            reduce using rule 17 (elifs -> else .)
    RBRACE          reduce using rule 17 (elifs -> else .)
    CASE            reduce using rule 17 (elifs -> else .)
    DEFAULT         reduce using rule 17 (elifs -> else .)


state 51

    (18) elifs -> elif .
    (19) elifs -> elif . elifs
    (17) elifs -> . else
    (18) elifs -> . elif
    (19) elifs -> . elif elifs
    (21) else -> . ELSE stmt_block
    (20) elif -> . ELSE IF LP bool_expr RP stmt_block

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 18 (elifs -> elif .)
    WHILE           reduce using rule 18 (elifs -> elif .)
    FOR             reduce using rule 18 (elifs -> elif .)
    SWITCH          reduce using rule 18 (elifs -> elif .)
    CONTENT         reduce using rule 18 (elifs -> elif .)
    $end            reduce using rule 18 (elifs -> elif .)
    RBRACE          reduce using rule 18 (elifs -> elif .)
    CASE            reduce using rule 18 (elifs -> elif .)
    DEFAULT         reduce using rule 18 (elifs -> elif .)
    ELSE            shift and go to state 52

  ! ELSE            [ reduce using rule 18 (elifs -> elif .) ]

    elif                           shift and go to state 51
    elifs                          shift and go to state 61
    else                           shift and go to state 50

state 52

    (21) else -> ELSE . stmt_block
    (20) elif -> ELSE . IF LP bool_expr RP stmt_block
    (15) stmt_block -> . LBRACE stmts RBRACE
    (16) stmt_block -> . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    IF              shift and go to state 63
    LBRACE          shift and go to state 43
    ELSE            reduce using rule 3 (stmt -> .)
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt_block                     shift and go to state 62
    stmt                           shift and go to state 42
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 53

    (15) stmt_block -> LBRACE stmts . RBRACE

    RBRACE          shift and go to state 64


state 54

    (22) whilestmt -> WHILE LP bool_expr RP stmt_block stmt .

    IF              reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)
    WHILE           reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)
    FOR             reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)
    SWITCH          reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)
    CONTENT         reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)
    $end            reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)
    RBRACE          reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)
    CASE            reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)
    DEFAULT         reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)
    ELSE            reduce using rule 22 (whilestmt -> WHILE LP bool_expr RP stmt_block stmt .)


state 55

    (23) forstmt -> FOR LP for_expr RP stmt_block stmt .

    IF              reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)
    WHILE           reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)
    FOR             reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)
    SWITCH          reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)
    CONTENT         reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)
    $end            reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)
    RBRACE          reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)
    CASE            reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)
    DEFAULT         reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)
    ELSE            reduce using rule 23 (forstmt -> FOR LP for_expr RP stmt_block stmt .)


state 56

    (24) for_expr -> contents SEMI contents SEMI . contents
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    contents                       shift and go to state 65

state 57

    (9) switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt . RBRACE stmt

    RBRACE          shift and go to state 66


state 58

    (10) case_stmt -> CASE . bool_expr COLON stmts
    (12) case_stmt -> CASE . bool_expr COLON stmts case_stmt
    (25) bool_expr -> . contents
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 67
    contents                       shift and go to state 29

state 59

    (11) case_stmt -> DEFAULT . COLON stmts

    COLON           shift and go to state 68


state 60

    (13) ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .

    IF              reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)
    WHILE           reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)
    FOR             reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)
    SWITCH          reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)
    CONTENT         reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)
    $end            reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)
    RBRACE          reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)
    CASE            reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)
    DEFAULT         reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)
    ELSE            reduce using rule 13 (ifstmt -> IF LP bool_expr RP stmt_block elifs stmt .)


state 61

    (19) elifs -> elif elifs .

    ELSE            reduce using rule 19 (elifs -> elif elifs .)
    IF              reduce using rule 19 (elifs -> elif elifs .)
    WHILE           reduce using rule 19 (elifs -> elif elifs .)
    FOR             reduce using rule 19 (elifs -> elif elifs .)
    SWITCH          reduce using rule 19 (elifs -> elif elifs .)
    CONTENT         reduce using rule 19 (elifs -> elif elifs .)
    $end            reduce using rule 19 (elifs -> elif elifs .)
    RBRACE          reduce using rule 19 (elifs -> elif elifs .)
    CASE            reduce using rule 19 (elifs -> elif elifs .)
    DEFAULT         reduce using rule 19 (elifs -> elif elifs .)


state 62

    (21) else -> ELSE stmt_block .

    ELSE            reduce using rule 21 (else -> ELSE stmt_block .)
    IF              reduce using rule 21 (else -> ELSE stmt_block .)
    WHILE           reduce using rule 21 (else -> ELSE stmt_block .)
    FOR             reduce using rule 21 (else -> ELSE stmt_block .)
    SWITCH          reduce using rule 21 (else -> ELSE stmt_block .)
    CONTENT         reduce using rule 21 (else -> ELSE stmt_block .)
    $end            reduce using rule 21 (else -> ELSE stmt_block .)
    RBRACE          reduce using rule 21 (else -> ELSE stmt_block .)
    CASE            reduce using rule 21 (else -> ELSE stmt_block .)
    DEFAULT         reduce using rule 21 (else -> ELSE stmt_block .)


state 63

    (20) elif -> ELSE IF . LP bool_expr RP stmt_block
    (13) ifstmt -> IF . LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> IF . LP bool_expr RP stmt_block stmt

    LP              shift and go to state 69


state 64

    (15) stmt_block -> LBRACE stmts RBRACE .

    ELSE            reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)
    IF              reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)
    WHILE           reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)
    FOR             reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)
    SWITCH          reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)
    CONTENT         reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)
    $end            reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)
    RBRACE          reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)
    CASE            reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)
    DEFAULT         reduce using rule 15 (stmt_block -> LBRACE stmts RBRACE .)


state 65

    (24) for_expr -> contents SEMI contents SEMI contents .

    RP              reduce using rule 24 (for_expr -> contents SEMI contents SEMI contents .)


state 66

    (9) switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    ELSE            reduce using rule 3 (stmt -> .)
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt                           shift and go to state 70
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 67

    (10) case_stmt -> CASE bool_expr . COLON stmts
    (12) case_stmt -> CASE bool_expr . COLON stmts case_stmt

    COLON           shift and go to state 71


state 68

    (11) case_stmt -> DEFAULT COLON . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 72
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 69

    (20) elif -> ELSE IF LP . bool_expr RP stmt_block
    (13) ifstmt -> IF LP . bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> IF LP . bool_expr RP stmt_block stmt
    (25) bool_expr -> . contents
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents

    CONTENT         shift and go to state 14

    bool_expr                      shift and go to state 73
    contents                       shift and go to state 29

state 70

    (9) switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .

    IF              reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    WHILE           reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    FOR             reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    SWITCH          reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    CONTENT         reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    $end            reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    RBRACE          reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    CASE            reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    DEFAULT         reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)
    ELSE            reduce using rule 9 (switch_stmt -> SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt .)


state 71

    (10) case_stmt -> CASE bool_expr COLON . stmts
    (12) case_stmt -> CASE bool_expr COLON . stmts case_stmt
    (1) stmts -> . stmt
    (2) stmts -> . stmt stmts
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmts                          shift and go to state 74
    stmt                           shift and go to state 2
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 72

    (11) case_stmt -> DEFAULT COLON stmts .

    RBRACE          reduce using rule 11 (case_stmt -> DEFAULT COLON stmts .)


state 73

    (20) elif -> ELSE IF LP bool_expr . RP stmt_block
    (13) ifstmt -> IF LP bool_expr . RP stmt_block elifs stmt
    (14) ifstmt -> IF LP bool_expr . RP stmt_block stmt

    RP              shift and go to state 75


state 74

    (10) case_stmt -> CASE bool_expr COLON stmts .
    (12) case_stmt -> CASE bool_expr COLON stmts . case_stmt
    (10) case_stmt -> . CASE bool_expr COLON stmts
    (11) case_stmt -> . DEFAULT COLON stmts
    (12) case_stmt -> . CASE bool_expr COLON stmts case_stmt

    RBRACE          reduce using rule 10 (case_stmt -> CASE bool_expr COLON stmts .)
    CASE            shift and go to state 58
    DEFAULT         shift and go to state 59

    case_stmt                      shift and go to state 76

state 75

    (20) elif -> ELSE IF LP bool_expr RP . stmt_block
    (13) ifstmt -> IF LP bool_expr RP . stmt_block elifs stmt
    (14) ifstmt -> IF LP bool_expr RP . stmt_block stmt
    (15) stmt_block -> . LBRACE stmts RBRACE
    (16) stmt_block -> . stmt
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    LBRACE          shift and go to state 43
    ELSE            reduce using rule 3 (stmt -> .)
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    stmt_block                     shift and go to state 77
    stmt                           shift and go to state 42
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9

state 76

    (12) case_stmt -> CASE bool_expr COLON stmts case_stmt .

    RBRACE          reduce using rule 12 (case_stmt -> CASE bool_expr COLON stmts case_stmt .)


state 77

    (20) elif -> ELSE IF LP bool_expr RP stmt_block .
    (13) ifstmt -> IF LP bool_expr RP stmt_block . elifs stmt
    (14) ifstmt -> IF LP bool_expr RP stmt_block . stmt
    (17) elifs -> . else
    (18) elifs -> . elif
    (19) elifs -> . elif elifs
    (3) stmt -> .
    (4) stmt -> . expr
    (5) stmt -> . ifstmt
    (6) stmt -> . whilestmt
    (7) stmt -> . forstmt
    (8) stmt -> . switch_stmt
    (21) else -> . ELSE stmt_block
    (20) elif -> . ELSE IF LP bool_expr RP stmt_block
    (26) expr -> . contents SEMI
    (27) expr -> . func_expr SEMI
    (13) ifstmt -> . IF LP bool_expr RP stmt_block elifs stmt
    (14) ifstmt -> . IF LP bool_expr RP stmt_block stmt
    (22) whilestmt -> . WHILE LP bool_expr RP stmt_block stmt
    (23) forstmt -> . FOR LP for_expr RP stmt_block stmt
    (9) switch_stmt -> . SWITCH LP bool_expr RP LBRACE case_stmt RBRACE stmt
    (34) contents -> . CONTENT
    (35) contents -> . CONTENT contents
    (28) func_expr -> . contents LP params RP

  ! reduce/reduce conflict for ELSE resolved using rule 3 (stmt -> .)
  ! reduce/reduce conflict for IF resolved using rule 3 (stmt -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (stmt -> .)
  ! reduce/reduce conflict for FOR resolved using rule 3 (stmt -> .)
  ! reduce/reduce conflict for SWITCH resolved using rule 3 (stmt -> .)
  ! reduce/reduce conflict for CONTENT resolved using rule 3 (stmt -> .)
  ! reduce/reduce conflict for $end resolved using rule 3 (stmt -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (stmt -> .)
  ! reduce/reduce conflict for CASE resolved using rule 3 (stmt -> .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 3 (stmt -> .)
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CONTENT resolved as shift
    $end            reduce using rule 3 (stmt -> .)
    RBRACE          reduce using rule 3 (stmt -> .)
    CASE            reduce using rule 3 (stmt -> .)
    DEFAULT         reduce using rule 3 (stmt -> .)
    ELSE            shift and go to state 52
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    SWITCH          shift and go to state 13
    CONTENT         shift and go to state 14

  ! ELSE            [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! IF              [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! WHILE           [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! FOR             [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! SWITCH          [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! CONTENT         [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! $end            [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! RBRACE          [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! CASE            [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! DEFAULT         [ reduce using rule 20 (elif -> ELSE IF LP bool_expr RP stmt_block .) ]
  ! ELSE            [ reduce using rule 3 (stmt -> .) ]
  ! IF              [ reduce using rule 3 (stmt -> .) ]
  ! WHILE           [ reduce using rule 3 (stmt -> .) ]
  ! FOR             [ reduce using rule 3 (stmt -> .) ]
  ! SWITCH          [ reduce using rule 3 (stmt -> .) ]
  ! CONTENT         [ reduce using rule 3 (stmt -> .) ]

    elifs                          shift and go to state 48
    stmt                           shift and go to state 49
    else                           shift and go to state 50
    elif                           shift and go to state 51
    expr                           shift and go to state 3
    ifstmt                         shift and go to state 4
    whilestmt                      shift and go to state 5
    forstmt                        shift and go to state 6
    switch_stmt                    shift and go to state 7
    contents                       shift and go to state 8
    func_expr                      shift and go to state 9
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 2 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 2 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 14 resolved as shift
WARNING: shift/reduce conflict for IF in state 36 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 36 resolved as shift
WARNING: shift/reduce conflict for FOR in state 36 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 36 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 36 resolved as shift
WARNING: shift/reduce conflict for IF in state 37 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 37 resolved as shift
WARNING: shift/reduce conflict for FOR in state 37 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 37 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 37 resolved as shift
WARNING: shift/reduce conflict for IF in state 38 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 38 resolved as shift
WARNING: shift/reduce conflict for FOR in state 38 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 38 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 38 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 41 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 41 resolved as shift
WARNING: shift/reduce conflict for FOR in state 41 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 41 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 43 resolved as shift
WARNING: shift/reduce conflict for FOR in state 43 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 43 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 43 resolved as shift
WARNING: shift/reduce conflict for IF in state 44 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 44 resolved as shift
WARNING: shift/reduce conflict for FOR in state 44 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 44 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 44 resolved as shift
WARNING: shift/reduce conflict for IF in state 45 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 45 resolved as shift
WARNING: shift/reduce conflict for FOR in state 45 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 45 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 45 resolved as shift
WARNING: shift/reduce conflict for IF in state 48 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 48 resolved as shift
WARNING: shift/reduce conflict for FOR in state 48 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 48 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 48 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 51 resolved as shift
WARNING: shift/reduce conflict for IF in state 52 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 52 resolved as shift
WARNING: shift/reduce conflict for FOR in state 52 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 52 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 52 resolved as shift
WARNING: shift/reduce conflict for IF in state 66 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 66 resolved as shift
WARNING: shift/reduce conflict for FOR in state 66 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 66 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 66 resolved as shift
WARNING: shift/reduce conflict for IF in state 68 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 68 resolved as shift
WARNING: shift/reduce conflict for FOR in state 68 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 68 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 68 resolved as shift
WARNING: shift/reduce conflict for IF in state 71 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 71 resolved as shift
WARNING: shift/reduce conflict for FOR in state 71 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 71 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 71 resolved as shift
WARNING: shift/reduce conflict for IF in state 75 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 75 resolved as shift
WARNING: shift/reduce conflict for FOR in state 75 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 75 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 75 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 77 resolved as shift
WARNING: shift/reduce conflict for IF in state 77 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 77 resolved as shift
WARNING: shift/reduce conflict for FOR in state 77 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 77 resolved as shift
WARNING: shift/reduce conflict for CONTENT in state 77 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (stmts -> stmt)
WARNING: rejected rule (stmt -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 26 resolved using rule (params -> <empty>)
WARNING: rejected rule (params -> param) in state 26
WARNING: reduce/reduce conflict in state 77 resolved using rule (stmt -> <empty>)
WARNING: rejected rule (elif -> ELSE IF LP bool_expr RP stmt_block) in state 77
WARNING: Rule (params -> param) is never reduced
WARNING: Rule (elif -> ELSE IF LP bool_expr RP stmt_block) is never reduced
